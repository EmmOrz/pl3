<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>反乌合之众 · 排列三组选6策略生成器</title>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <style>
        /* ========== 基础重置与全局变量 ========== */
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #131a2b;
            --bg-tertiary: #1a2440;
            --accent-blue: #3b82f6;
            --accent-purple: #8b5cf6;
            --accent-cyan: #06b6d4;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #2d3a5c;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --gradient-primary: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            --gradient-card: linear-gradient(145deg, #1e2a4a, #151d35);
            --shadow-glow: 0 0 30px rgba(59, 130, 246, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* ========== 布局容器 ========== */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 24px;
            margin-top: 24px;
        }

        @media (max-width: 1024px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }

        /* ========== 头部区域 ========== */
        header {
            text-align: center;
            padding: 40px 20px;
            background: var(--gradient-card);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--gradient-primary);
        }

        header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
        }

        header .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
            letter-spacing: 2px;
        }

        header .badge {
            display: inline-block;
            margin-top: 16px;
            padding: 6px 16px;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid var(--accent-purple);
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--accent-purple);
        }

        /* ========== 主内容区 ========== */
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        /* ========== 卡片通用样式 ========== */
        .card {
            background: var(--gradient-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            transition: all 0.3s ease;
        }

        .card:hover {
            border-color: var(--accent-blue);
            box-shadow: var(--shadow-glow);
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title .icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--gradient-primary);
            border-radius: 8px;
            font-size: 1rem;
        }

        /* ========== 策略选择卡片 ========== */
        .strategy-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }

        @media (max-width: 768px) {
            .strategy-grid {
                grid-template-columns: 1fr;
            }
        }

        .strategy-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .strategy-card:hover {
            border-color: var(--accent-blue);
            transform: translateY(-2px);
        }

        .strategy-card.active {
            border-color: var(--accent-purple);
            background: rgba(139, 92, 246, 0.1);
        }

        .strategy-card.active::before {
            content: '✓';
            position: absolute;
            top: 12px;
            right: 12px;
            width: 24px;
            height: 24px;
            background: var(--accent-purple);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: white;
        }

        .strategy-card h3 {
            font-size: 1rem;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .strategy-card p {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .strategy-card .tag {
            display: inline-block;
            margin-top: 12px;
            padding: 4px 10px;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--accent-cyan);
        }

        /* ========== 高级选项 ========== */
        .options-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 16px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .checkbox-item input[type="checkbox"] {
            display: none;
        }

        .checkbox-item .checkmark {
            width: 22px;
            height: 22px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            background: var(--bg-secondary);
        }

        .checkbox-item input:checked + .checkmark {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
        }

        .checkbox-item input:checked + .checkmark::after {
            content: '✓';
            color: white;
            font-size: 14px;
        }

        .checkbox-item span {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* ========== 生成按钮 ========== */
        .generate-btn {
            width: 100%;
            padding: 18px 32px;
            font-size: 1.2rem;
            font-weight: 600;
            color: white;
            background: var(--gradient-primary);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 40px rgba(59, 130, 246, 0.4);
        }

        .generate-btn:active {
            transform: translateY(0);
        }

        .generate-btn.loading {
            pointer-events: none;
            opacity: 0.7;
        }

        .generate-btn .spinner {
            display: none;
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        .generate-btn.loading .spinner {
            display: inline-block;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ========== 结果展示区 ========== */
        .results-section {
            display: none;
        }

        .results-section.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 24px;
        }

        @media (max-width: 768px) {
            .results-grid {
                grid-template-columns: 1fr;
            }
        }

        .result-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            text-align: center;
            position: relative;
            overflow: hidden;
            animation: flipIn 0.6s ease;
        }

        .result-card:nth-child(2) { animation-delay: 0.1s; }
        .result-card:nth-child(3) { animation-delay: 0.2s; }

        @keyframes flipIn {
            0% { transform: perspective(400px) rotateY(90deg); opacity: 0; }
            100% { transform: perspective(400px) rotateY(0); opacity: 1; }
        }

        .result-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-primary);
        }

        .result-card .label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 12px;
        }

        .result-card .number {
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: 8px;
            background: var(--gradient-primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 16px;
            font-family: 'Monaco', 'Consolas', monospace;
        }

        .result-card .analysis {
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-align: left;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            line-height: 1.6;
        }

        .result-card .analysis .highlight {
            color: var(--accent-cyan);
            font-weight: 500;
        }

        /* ========== 大师洞察 ========== */
        .insight-box {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(59, 130, 246, 0.1));
            border: 1px solid var(--accent-purple);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
        }

        .insight-box .quote {
            font-style: italic;
            color: var(--text-primary);
            font-size: 1rem;
            line-height: 1.6;
        }

        .insight-box .author {
            margin-top: 12px;
            color: var(--accent-purple);
            font-size: 0.85rem;
        }

        /* ========== 侧边栏 ========== */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .sidebar .card {
            padding: 20px;
        }

        /* ========== 近期开奖 ========== */
        .history-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 12px;
        }

        .history-list::-webkit-scrollbar {
            width: 6px;
        }

        .history-list::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 3px;
        }

        .history-list::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .history-item:hover {
            background: var(--bg-tertiary);
        }

        .history-item .num {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-cyan);
            letter-spacing: 4px;
        }

        .history-item .date {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .history-item .delete-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
            border-radius: 4px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
        }

        .history-item:hover .delete-btn {
            opacity: 1;
        }

        .history-item .delete-btn:hover {
            background: var(--danger);
            color: white;
        }

        /* ========== 添加号码 ========== */
        .add-number-form {
            display: flex;
            gap: 10px;
            margin-top: 16px;
        }

        .add-number-form input {
            flex: 1;
            padding: 10px 14px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
            outline: none;
            transition: all 0.2s ease;
        }

        .add-number-form input:focus {
            border-color: var(--accent-blue);
        }

        .add-number-form input::placeholder {
            color: var(--text-muted);
        }

        .add-number-form button {
            padding: 10px 16px;
            background: var(--accent-blue);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .add-number-form button:hover {
            background: var(--accent-purple);
        }

        /* ========== 热点号码 ========== */
        .hotspot-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }

        .hotspot-tag {
            padding: 6px 12px;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 6px;
            font-size: 0.85rem;
            color: var(--danger);
            font-family: 'Monaco', 'Consolas', monospace;
        }

        /* ========== 数据加载状态 ========== */
        .loading-state {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .loading-state .spinner-large {
            width: 40px;
            height: 40px;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        /* ========== 统计信息 ========== */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 16px;
        }

        .stat-item {
            background: var(--bg-secondary);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-item .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-cyan);
        }

        .stat-item .label {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* ========== 避开期数选择 ========== */
        .avoid-period {
            margin-top: 16px;
        }

        .avoid-period label {
            display: block;
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .avoid-period select {
            width: 100%;
            padding: 10px 14px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
            outline: none;
            cursor: pointer;
        }

        .avoid-period select:focus {
            border-color: var(--accent-blue);
        }

        /* ========== 响应式与分析面板美化（移动端优化） ========= */
        .stats-grid {
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 12px;
        }

        .analysis-content h3, .analysis-content h4 {
            margin: 0 0 8px;
        }

        .analysis-recommendation .rec-item {
            display: inline-block;
            margin-right: 8px;
            padding: 6px 8px;
            border-radius: 6px;
            background: var(--bg-tertiary);
            font-family: monospace;
            color: var(--accent-cyan);
            font-weight: 600;
            white-space: nowrap;
        }

        .analysis-recommendation .rec-item small { color: var(--text-secondary); font-weight: 400; margin-left: 6px; }

        @media (max-width: 640px) {
            .stat-item .value { font-size: 1.25rem; }
            .stats-grid { gap: 8px; }
            .analysis-recommendation .rec-item { display: block; margin-bottom: 8px; white-space: normal; }
            #analysisContent { font-size: 0.95rem; }
            .analysis-content { padding: 6px; }
            .analysis-grid-2 { grid-template-columns: 1fr; }
        }

        /* ========== 错误提示 ========== */
        .error-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            background: var(--danger);
            color: white;
            border-radius: 8px;
            font-size: 0.9rem;
            z-index: 1000;
            animation: slideIn 0.3s ease;
            display: none;
        }

        .error-toast.show {
            display: block;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* ========== 原理说明 ========== */
        .principle-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.7;
            margin-top: 12px;
        }

        .principle-text strong {
            color: var(--accent-cyan);
        }

        /* ========== 刷新按钮 ========== */
        .refresh-btn {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: auto;
        }

        .refresh-btn:hover {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }

        .card-header .card-title {
            margin-bottom: 0;
        }

        /* ========== 完整开奖记录表格样式 ========== */
        .full-table-section .table-container {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            max-width: 100%;
        }

        .full-history-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-secondary);
        }

        .full-history-table th,
        .full-history-table td {
            padding: 12px;
            text-align: left;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
            white-space: nowrap;
        }

        @media (max-width: 768px) {
            .full-history-table th,
            .full-history-table td {
                padding: 10px;
                font-size: 0.82rem;
            }

            .full-table-section .table-container {
                max-height: 420px;
            }
        }

        /* 更小屏幕：保留表格结构，允许横向滚动以保持列的一致性 */
        @media (max-width: 480px) {
            .full-history-table th,
            .full-history-table td {
                padding: 8px;
                font-size: 0.78rem;
                white-space: nowrap;
            }
            .full-table-section .table-container {
                max-height: 520px;
                -webkit-overflow-scrolling: touch;
            }
        }

        /* 分析区：确保和值/大众显示自动换行以防溢出 */
        .sum-analysis-wrap, .popular-wrap { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
        .sum-analysis-wrap > div, .popular-wrap > span { flex: 0 1 auto; }
        .analysis-recommendation .rec-item { max-width: 100%; word-break: break-word; }
        .hotspot-tag { max-width: 100%; word-break: break-word; }
        @media (max-width: 640px) { .sum-analysis-wrap > div, .popular-wrap > span { flex: 0 1 48%; } }

        .load-more {
            padding: 10px 16px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
        }

        .load-more:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <!-- 错误提示 -->
    <div class="error-toast" id="errorToast"></div>

    <div class="container">
        <!-- 头部 -->
        <header>
            <h1>反乌合之众 · 排列三组选6策略生成器</h1>
            <p class="subtitle">用数学避开人群，用理性赢得体验</p>
            <span class="badge">基于行为金融学与博弈论</span>
        </header>

        <!-- 主仪表盘 -->
        <div class="dashboard">
            <!-- 主内容区 -->
            <main class="main-content">
                <!-- 策略选择 -->
                <section class="card">
                    <h2 class="card-title">
                        <span class="icon">⚡</span>
                        选择策略引擎
                    </h2>
                    <div class="strategy-grid">
                        <div class="strategy-card active" data-strategy="math">
                            <h3>数学均匀分布</h3>
                            <p>基于和值、跨度、奇偶比、大小比四维均匀分布，生成彼此差异化的号码组合。</p>
                            <span class="tag">推荐 · 理性派</span>
                        </div>
                        <div class="strategy-card" data-strategy="culture">
                            <h3>文化避开策略</h3>
                            <p>主动避开吉利数字6、8、9，优先使用0、2、5、7等"中性"数字，生成视觉上"不美观"的组合。</p>
                            <span class="tag">反直觉派</span>
                        </div>
                        <div class="strategy-card" data-strategy="cold">
                            <h3>冷僻趋势策略</h3>
                            <p>深度分析近期开奖，最大程度避开热号，选择出现频率最低的数字组合。</p>
                            <span class="tag">数据派</span>
                        </div>
                        <div class="strategy-card" data-strategy="hot">
                            <h3>追热避冷策略</h3>
                            <p>顺势而为，将近期热码作为核心，组合生成号码，确保和值落在热区。</p>
                            <span class="tag">趋势派</span>
                        </div>
                        <div class="strategy-card" data-strategy="coldreturn">
                            <h3>赌冷回归策略</h3>
                            <p>基于概率平均律，选用长期遗漏的冷码，搭配中性码组合。</p>
                            <span class="tag">逆势博弈</span>
                        </div>
                        <div class="strategy-card" data-strategy="precision">
                            <h3>精确逆向策略</h3>
                            <p>避开导致组选6奖金最低的"大众号"，直接与大众资金对赌。</p>
                            <span class="tag">资金博弈派</span>
                        </div>
                    </div>

                    <!-- 分析期数选择 -->
                    <div class="options-row" style="margin-top: 20px;">
                        <div style="flex: 1;">
                            <label style="display: block; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 8px;">分析期数：</label>
                            <select id="analysisPeriods" style="width: 100%; padding: 10px 14px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 0.95rem; outline: none; cursor: pointer;">
                                <option value="10">最近 10 期</option>
                                <option value="30" selected>最近 30 期</option>
                                <option value="50">最近 50 期</option>
                                <option value="100">最近 100 期</option>
                                <option value="200">最近 200 期</option>
                                <option value="500">最近 500 期</option>
                            </select>
                        </div>
                        <div style="flex: 1;">
                            <label style="display: block; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 8px;">避开最近 N 期开奖号码：</label>
                            <select id="avoidPeriods" style="width: 100%; padding: 10px 14px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 0.95rem; outline: none; cursor: pointer;">
                                <option value="20">最近 20 期</option>
                                <option value="30" selected>最近 30 期</option>
                                <option value="50">最近 50 期</option>
                                <option value="100">最近 100 期</option>
                                <option value="150">最近 150 期</option>
                                <option value="200">最近 200 期</option>
                            </select>
                        </div>
                    </div>

                    <!-- 高级选项 -->
                    <div class="options-row">
                        <label class="checkbox-item">
                            <input type="checkbox" id="strictMode">
                            <span class="checkmark"></span>
                            <span>【严格模式】强制避开所有近期号码数字</span>
                        </label>
                        <label class="checkbox-item">
                            <input type="checkbox" id="aggressiveMode">
                            <span class="checkmark"></span>
                            <span>【激进模式】允许包含一个"4"</span>
                        </label>
                    </div>
                </section>

                <!-- 生成按钮 -->
                <button class="generate-btn" id="generateBtn">
                    <span class="spinner"></span>
                    生成我的三注策略号码
                </button>

                <!-- 结果展示区 -->
                <section class="results-section" id="resultsSection">
                    <div class="card">
                        <h2 class="card-title">
                            <span class="icon">🎯</span>
                            策略生成结果
                        </h2>
                        <div class="results-grid" id="resultsGrid">
                            <!-- 动态生成 -->
                        </div>

                        <!-- 大师洞察 -->
                        <div class="insight-box">
                            <p class="quote" id="insightQuote">"大众追逐规律，而真正的随机性往往面目可憎。"</p>
                            <p class="author">— 反乌合之众策略系统</p>
                        </div>
                    </div>
                </section>
            </main>

            <!-- 侧边栏 -->
            <aside class="sidebar">
                <!-- 近期开奖 -->
                <article class="card">
                    <div class="card-header">
                        <h3 class="card-title">
                            <span class="icon">📊</span>
                            近期开奖记录
                        </h3>
                        <button class="refresh-btn" id="refreshBtn">刷新数据</button>
                        <button class="refresh-btn" id="exportBtn">保存为单文件</button>
                    </div>
                    <div class="history-list" id="historyList">
                        <div class="loading-state">
                            <div class="spinner-large"></div>
                            <p>正在获取开奖数据...</p>
                        </div>
                    </div>

                    
                    <div class="add-number-form">
                        <input type="text" id="newNumber" placeholder="手动添加号码 (如: 123)" maxlength="3">
                        <button id="addNumberBtn">添加</button>
                    </div>
                </article>

                <!-- 统计信息 -->
                <article class="card">
                    <h3 class="card-title">
                        <span class="icon">📈</span>
                        数字热度分析
                    </h3>
                    <div class="stats-grid" id="statsGrid">
                        <!-- 动态生成 -->
                    </div>
                </article>

                <!-- 热点号码 -->
                <article class="card">
                    <h3 class="card-title">
                        <span class="icon">🚫</span>
                        应避开的热点号码
                    </h3>
                    <div class="hotspot-grid" id="hotspotGrid">
                        <!-- 动态生成 -->
                    </div>
                </article>

                <!-- 策略原理 -->
                <article class="card">
                    <h3 class="card-title">
                        <span class="icon">💡</span>
                        策略原理
                    </h3>
                    <p class="principle-text">
                        本生成器基于<strong>行为金融学</strong>与<strong>博弈论</strong>设计。核心理念：当多数人选择相同号码时，即使中奖也需分摊奖金。
                        <br><br>
                        我们通过<strong>避开键盘组合</strong>（123、456等）、<strong>吉利数字</strong>（666、888等）、<strong>生日相关</strong>（01-31）以及<strong>近期热号</strong>，
                        帮助您找到被大众忽视的"冷门"组合。
                        <br><br>
                        <strong>记住：</strong>这不是预测工具，而是差异化选择工具。
                    </p>
                </article>
            </aside>
        </div>

        <!-- 数据分析区域 -->
        <section class="card" id="analysisSection" style="margin-top: 24px; display: none;">
            <h2 class="card-title">
                <span class="icon">📊</span>
                数据分析报告
            </h2>
            <div id="analysisContent" style="margin-top: 20px;">
                <!-- 动态生成数据分析表格 -->
            </div>
        </section>

        <!-- 完整开奖记录表格（分页 / 无限加载） -->
        <section class="card full-table-section" id="fullTableSection" style="margin-top: 24px;">
            <h2 class="card-title">
                <span class="icon">📚</span>
                完整开奖记录（近500期）
            </h2>
            <div class="table-container" id="fullTableContainer" style="max-height: 420px; overflow-y: auto;">
                <table class="full-history-table" id="fullHistoryTable">
                    <thead>
                        <tr>
                            <th>期号</th>
                            <th>日期</th>
                            <th>号码</th>
                            <th>直选 注数</th>
                            <th>直选 奖金</th>
                            <th>组选3 注数</th>
                            <th>组选3 奖金</th>
                            <th>组选6 注数</th>
                            <th>组选6 奖金</th>
                            <th>销售额</th>
                            <th>公告</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div style="display:flex; justify-content:center; margin-top:12px;">
                <button class="load-more" id="loadMoreBtn">加载更多</button>
            </div>
        </section>
    </div>

    <script>
        /**
         * ========================================
         * 反乌合之众 · 排列三组选6策略生成器
         * 核心算法与交互逻辑
         * ========================================
         */

        // ========== 全局配置与数据 ==========
        const CONFIG = {
            // API 配置
            API_URL: 'https://webapi.sporttery.cn/gateway/lottery/getHistoryPageListV1.qry?gameNo=35&provinceId=0&pageSize=100&isVerify=1&pageNo=1&termLimits=100',

            // 代理配置（当浏览器直接请求被拦截时会尝试这些代理，推荐部署 Cloudflare Worker 并把 URL 填到下面）
            PROXY_ENDPOINT: '', // 示例: 'https://your-worker.example/fetch?url='
            PROXY_AUTO_TRY: true, // 自动在请求失败时尝试代理
            // 用于模拟 curl 的头（注意：浏览器不允许随意设置 Referer/Origin，需通过服务器端代理设置）
            PROXY_DEFAULT_REFERER: 'https://webapi.sporttery.cn/',
            PROXY_DEFAULT_ORIGIN: 'https://webapi.sporttery.cn' ,


            // 热点号码库（大众高频选择）
            HOTSPOT_NUMBERS: [
                // 键盘组合
                '123', '234', '345', '456', '567', '678', '789',
                '321', '432', '543', '654', '765', '876', '987',
                '147', '258', '369', '741', '852', '963',
                '159', '357', '753', '951',
                '123', '456', '789',
                // 吉利数字组合
                '666', '888', '999', '168', '268', '368', '518', '618', '688', '818', '868', '886', '888',
                '066', '088', '068', '086', '006', '008',
                '116', '118', '166', '188', '668', '698', '689', '896', '869',
                // 顺子与豹子
                '000', '111', '222', '333', '444', '555', '777',
                '012', '890',
                // 生日相关高频（月份01-12，日期01-31的常见组合）
                '101', '102', '103', '104', '105', '106', '107', '108', '109', '110', '111', '112',
                '201', '202', '203', '204', '205', '206', '207', '208', '209', '210', '211', '212',
                '301', '302', '303', '304', '305', '306', '307', '308', '309', '310', '311', '312',
                '120', '121', '122', '123', '124', '125', '126', '127', '128', '129', '130', '131',
                '520', '521', '502', '512', // 网络流行
                '214', '314', '514', '714', '914', // 情人节相关
            ],

            // 大师洞察语录
            INSIGHTS: [
                "大众追逐规律，而真正的随机性往往面目可憎。",
                "你避开的不是数字，是人群的非理性共识。",
                "在概率面前，所有数字生而平等，但选择者却并非如此。",
                "聪明的策略不是预测中奖号码，而是避开拥挤的选择。",
                "当所有人都在追逐幸运数字时，你选择了数学。",
                "博弈论告诉我们：最优策略往往是反直觉的。",
                "独立思考的代价是孤独，但回报是差异化的可能。",
                "统计学家不信命运，他们相信分布。",
                "避开人群，不是为了特立独行，而是为了数学效率。",
                "每一个热门号码背后，都有无数人在分摊期望值。"
            ]
        };

        // 全局状态
        let state = {
            historyNumbers: [],      // 近期开奖号码
            selectedStrategy: 'math', // 当前策略
            isLoading: false
        };

        // ========== 工具函数 ==========

        /**
         * 显示错误提示
         */
        function showError(message) {
            const toast = $('#errorToast');
            toast.text(message).addClass('show');
            setTimeout(() => toast.removeClass('show'), 3000);
        }

        /**
         * 解析号码为数组
         */
        function parseNumber(num) {
            return num.toString().padStart(3, '0').split('').map(Number);
        }

        /**
         * 计算组选6的排序形式（升序）
         */
        function sortNumber(num) {
            return parseNumber(num).sort((a, b) => a - b).join('');
        }

        /**
         * 判断是否为组选6（三个数字都不同）
         */
        function isZuxuan6(num) {
            const digits = parseNumber(num);
            return new Set(digits).size === 3;
        }

        /**
         * 计算和值
         */
        function calcSum(num) {
            return parseNumber(num).reduce((a, b) => a + b, 0);
        }

        /**
         * 计算跨度
         */
        function calcSpan(num) {
            const digits = parseNumber(num);
            return Math.max(...digits) - Math.min(...digits);
        }

        /**
         * 计算奇偶比
         */
        function calcOddEven(num) {
            const digits = parseNumber(num);
            const odd = digits.filter(d => d % 2 === 1).length;
            return `${odd}:${3 - odd}`;
        }

        /**
         * 计算大小比（5-9为大，0-4为小）
         */
        function calcBigSmall(num) {
            const digits = parseNumber(num);
            const big = digits.filter(d => d >= 5).length;
            return `${big}:${3 - big}`;
        }

        /**
         * 检查是否为等差数列
         */
        function isArithmeticSequence(num) {
            const digits = parseNumber(num).sort((a, b) => a - b);
            return (digits[1] - digits[0]) === (digits[2] - digits[1]);
        }

        /**
         * 检查是否包含热点组合
         */
        function isHotspot(num) {
            const sorted = sortNumber(num);
            return CONFIG.HOTSPOT_NUMBERS.some(hot => sortNumber(hot) === sorted);
        }

        /**
         * 获取近期号码中各数字出现频率
         * 修复：支持传入已截取的列表或传入完整列表并由 limit 限制，避免在分析时出现错误统计
         */
        function getDigitFrequency(historyList, limit) {
            const freq = Array(10).fill(0);
            const list = Array.isArray(historyList) ? (limit ? historyList.slice(0, limit) : historyList) : [];
            list.forEach(item => {
                parseNumber(item.number).forEach(d => freq[d]++);
            });
            return freq;
        }

        // ========== API 数据获取 ==========

        /**
         * 从官方API获取指定页数的开奖数据
         */


        /**
         * 从官方API获取近期开奖数据（支持分页获取多期）
         */
        async function fetchHistoryData(totalPages = 5, pageSize = 100) {
            // 默认只进行 5 次请求，每次请求 pageSize 条（建议 100），合计近 500 期，减少多次加载和服务器压力
            state.isLoading = true;
            $('#historyList').html('<div class="loading-state"><div class="spinner-large"></div><p>正在获取开奖数据...</p></div>');

            // 如果勾选了“使用内置数据”，或存在本地存储数据，优先使用本地/内置数据
            const useLocal = $('#useLocalData').length && $('#useLocalData').is(':checked');
            // 如果页面内嵌了 PRELOADED_HISTORY（例如：用户生成的单文件 HTML），优先使用它以支持离线访问
            if (window.PRELOADED_HISTORY && Array.isArray(window.PRELOADED_HISTORY) && window.PRELOADED_HISTORY.length) {
                state.historyNumbers = JSON.parse(JSON.stringify(window.PRELOADED_HISTORY)).sort((a, b) => parseInt(b.period || 0) - parseInt(a.period || 0));
                state.isLoading = false;
                $('#historyList').html('');
                renderHistoryList();
                renderStats();
                // 记录用户分析期数意图并在界面上设置（最多500期）并先生成策略结果
                state.requestedAnalysisTarget = parseInt($('#analysisPeriods').val()) || 100;
                $('#analysisPeriods').val(Math.min(state.requestedAnalysisTarget, state.historyNumbers.length, 500));
                generateAnalysisReport();
                const initResults = generateNumbers(state.selectedStrategy);
                renderResults(initResults);
                setupFullHistoryTable();
                return true;
            }

                // 优先使用 localStorage 中的缓存（如果存在），便于本地覆盖页面后无需重复粘贴
                try {
                    const stored = localStorage.getItem('anti_crowd_history');
                    if (stored) {
                        const parsedStored = JSON.parse(stored);
                        if (Array.isArray(parsedStored) && parsedStored.length) {
                            state.historyNumbers = parsedStored.sort((a, b) => parseInt(b.period || 0) - parseInt(a.period || 0));
                            state.isLoading = false;
                            $('#historyList').html('');
                            renderHistoryList();
                            renderStats();
                            // 记录用户分析期数意图并在界面上设置（最多500期）并先生成策略结果
                            state.requestedAnalysisTarget = parseInt($('#analysisPeriods').val()) || 100;
                            $('#analysisPeriods').val(Math.min(state.requestedAnalysisTarget, state.historyNumbers.length, 500));
                            generateAnalysisReport();
                            const initResults = generateNumbers(state.selectedStrategy);
                            renderResults(initResults);
                            setupFullHistoryTable();
                            return true;
                        }
                    }
                } catch (e) {
                    console.warn('读取 localStorage 失败', e);
                }

            // 使用 fetch 获取单页并标准化返回
            // 通过代理列表尝试拉取并返回解析后的 JSON（支持可能被 JSONP 包裹的情况）
            async function fetchJsonThroughProxy(proxies, target) {
                let lastErr = null;
                for (const p of proxies) {
                    try {
                        const prefix = p;
                        const url = prefix.indexOf('{url}') !== -1 ? prefix.replace('{url}', encodeURIComponent(target)) : prefix + encodeURIComponent(target);
                        const resp = await fetch(url, { method: 'GET' });
                        if (!resp.ok) throw new Error('http:' + resp.status);
                        let data = null;
                        try { data = await resp.json(); }
                        catch (ee) {
                            const text = await resp.text();
                            const maybe = text.replace(/^[^(]*\((([\s\S]*)?)\);?$/, '$1');
                            data = JSON.parse(maybe);
                        }
                        return data;
                    } catch (err) {
                        lastErr = err;
                        console.warn('proxy fetch failed', p, err);
                        continue;
                    }
                }
                throw lastErr || new Error('proxy_failed');
            }

            async function fetchHistoryPageRuntime(pageNo, pageSize) {
                const url = (CONFIG.API_URL || '').replace(/pageNo=\d+/, 'pageNo=' + pageNo).replace(/pageSize=\d+/, 'pageSize=' + pageSize);
                const target = url.replace(/callback=\?/, '');

                // 优先尝试用户配置的代理（可由 Cloudflare Worker 等设置 Referer/Origin，并返回 CORS 允许）
                if (CONFIG.PROXY_ENDPOINT && CONFIG.PROXY_AUTO_TRY) {
                    try {
                        const data = await fetchJsonThroughProxy([CONFIG.PROXY_ENDPOINT], target);
                        let list = null;
                        if (Array.isArray(data)) list = data;
                        else if (data.value && Array.isArray(data.value.list)) list = data.value.list;
                        else if (Array.isArray(data.list)) list = data.list;
                        else if (data.data && Array.isArray(data.data.list)) list = data.data.list;
                        else throw new Error('no_list_in_response');
                        return list.map(normalizeApiItem).filter(i => i && i.period && i.number);
                    } catch (e) {
                        console.warn('configured proxy fetch failed', e);
                        // 继续尝试直接请求或公共代理
                    }
                }

                try {
                    const resp = await fetch(url, {
                        method: 'GET',
                        credentials: 'omit',
                        referrer: CONFIG.PROXY_DEFAULT_REFERER || undefined,
                        referrerPolicy: 'no-referrer-when-downgrade',
                        headers: {
                            'X-Requested-With': 'XMLHttpRequest'
                        }
                    });
                    if (!resp.ok) {
                        const t = await resp.text().catch(() => '');
                        const err = new Error('http_error:' + resp.status + ' ' + resp.statusText + ' ' + (t || '').slice(0,200));
                        err.status = resp.status;
                        throw err;
                    }
                    const data = await resp.json();
                    let list = null;
                    if (Array.isArray(data)) list = data;
                    else if (data.value && Array.isArray(data.value.list)) list = data.value.list;
                    else if (Array.isArray(data.list)) list = data.list;
                    else if (data.data && Array.isArray(data.data.list)) list = data.data.list;
                    else throw new Error('no_list_in_response');
                    return list.map(normalizeApiItem).filter(i => i && i.period && i.number);
                } catch (e) {
                    console.warn('fetchHistoryPageRuntime error', e);
                    if (e && e.message && (e.message.indexOf('567') !== -1 || e.message.indexOf('blocked_by_edgeone') !== -1 || (e.status && e.status === 567))) {
                        throw new Error('blocked_by_edgeone');
                    }
                    throw e;
                }
            }

            try {
                const pageSizeLocal = pageSize;
                const maxRetries = 2;

                // 1) 先拉取第一页并立即使用（提升体验）
                let firstPageItems = [];
                let attempt = 0;
                while (attempt <= maxRetries) {
                    try {
                        $('#historyList').html(`<div class="loading-state"><div class="spinner-large"></div><p>正在获取开奖数据... （第 1/${totalPages} 页）</p></div>`);
                        firstPageItems = await fetchHistoryPageRuntime(1, pageSizeLocal);
                        break;
                    } catch (err) {
                        attempt++;
                        console.warn('fetch first page failed', 'attempt', attempt, err);
                        if (err && err.message && err.message.indexOf('blocked_by_edgeone') !== -1) throw err;
                        if (attempt > maxRetries) throw err;
                        await new Promise(r => setTimeout(r, 600 * attempt));
                    }
                }

                if (!firstPageItems || firstPageItems.length === 0) throw new Error('未获取到任何数据');

                // 应用第一页数据并立即渲染与分析
                const unique = new Map();
                firstPageItems.forEach(item => { if (item.period && !unique.has(item.period)) unique.set(item.period, item); });
                state.historyNumbers = Array.from(unique.values()).sort((a, b) => parseInt(b.period || 0) - parseInt(a.period || 0));

                // 保存并注入（先保存第一页）
                try { localStorage.setItem('anti_crowd_history', JSON.stringify(state.historyNumbers.slice(0, 500))); } catch (e) { console.warn('保存 localStorage 失败', e); }
                try {
                    const existing = document.getElementById('preloaded-history-script');
                    if (existing) existing.remove();
                    const s = document.createElement('script');
                    s.id = 'preloaded-history-script';
                    s.type = 'text/javascript';
                    s.textContent = 'window.PRELOADED_HISTORY = ' + JSON.stringify(state.historyNumbers.slice(0,500)) + ';';
                    document.body.appendChild(s);
                } catch (ee) { console.warn('注入 PRELOADED_HISTORY 到页面失败', ee); }

                $('#historyList').html('');
                renderHistoryList();
                renderStats();
                // 记录用户原始选择（用于后台加载完成后决定是否重新分析）
                const requested = parseInt($('#analysisPeriods').val()) || 100;
                state.requestedAnalysisTarget = requested;
                // 将界面选择设为当前可用的期数（不丢失用户意图）
                $('#analysisPeriods').val(Math.min(requested, state.historyNumbers.length, 500));
                generateAnalysisReport();
                const initResults = generateNumbers(state.selectedStrategy);
                renderResults(initResults);
                setupFullHistoryTable();

                // 2) 后台按页顺序加载剩余页面并追加到 state（不阻塞初始分析）
                (async function fetchRemainingPages() {
                    let allUnique = new Map(state.historyNumbers.map(i=>[i.period, i]));
                    for (let pageNo = 2; pageNo <= totalPages; pageNo++) {
                        let attemptP = 0;
                        let pageItems = [];
                        while (attemptP <= maxRetries) {
                            try {
                                // 在后台静默加载，UI 可选择显示小幅提示
                                pageItems = await fetchHistoryPageRuntime(pageNo, pageSizeLocal);
                                break;
                            } catch (err) {
                                attemptP++;
                                console.warn('background fetch page failed', pageNo, 'attempt', attemptP, err);
                                if (err && err.message && err.message.indexOf('blocked_by_edgeone') !== -1) { throw err; }
                                if (attemptP > maxRetries) { break; }
                                await new Promise(r => setTimeout(r, 600 * attemptP));
                            }
                        }

                        if (pageItems && pageItems.length) {
                            pageItems.forEach(item => { if (item.period && !allUnique.has(item.period)) allUnique.set(item.period, item); });

                            // 将追加的数据合并回 state，并保留最新 500 条
                            state.historyNumbers = Array.from(allUnique.values()).sort((a,b)=> parseInt(b.period||0) - parseInt(a.period||0));
                            try { localStorage.setItem('anti_crowd_history', JSON.stringify(state.historyNumbers.slice(0,500))); } catch(e) { console.warn('保存 localStorage 失败', e); }

                            // 刷新短列表与统计（即时更新近期开奖记录），并让完整表格可继续加载新页
                            renderHistoryList();
                            renderStats();

                            if (state.fullTable) {
                                // 更新总页数并尽量自动加载下一页到表格以便可见（用户体验友好）
                                state.fullTable.totalPages = Math.ceil((state.historyNumbers || []).length / state.fullTable.pageSize);
                                if (!state.fullTable.loading && state.fullTable.currentPage < state.fullTable.totalPages) {
                                    loadNextTablePage();
                                }
                            }
                        }

                        // 小延迟，避免过快连续请求
                        await new Promise(r => setTimeout(r, 200));
                    }

                    // 所有页面加载完毕后：若用户原先希望分析 500 期并且已加载到 500 条，恢复选择并重新运行分析
                    $('#backgroundLoadNotice').remove();
                    if (state.requestedAnalysisTarget && state.historyNumbers.length >= state.requestedAnalysisTarget) {
                        $('#analysisPeriods').val(state.requestedAnalysisTarget);
                        generateAnalysisReport();
                        const refreshed = generateNumbers(state.selectedStrategy);
                        renderResults(refreshed);
                    }
                })();

                // 显示后台加载提示（非阻塞）
                if (totalPages > 1) {
                    $('#historyList').append('<div id="backgroundLoadNotice" style="padding:8px;color:var(--text-secondary);font-size:0.85rem;">正在后台加载更多记录…</div>');
                }

                return true;
            } catch (error) {
                console.error('获取开奖数据失败:', error);

                // 若启用了自动代理尝试（配置或界面开启），先自动尝试代理（优先：自定义 -> CONFIG.PROXY_ENDPOINT -> 公共代理）
                try {
                    const autoUi = $('#autoProxyTry').length && $('#autoProxyTry').is(':checked');
                    const autoConfig = !!CONFIG.PROXY_AUTO_TRY;
                    const shouldAuto = autoConfig || autoUi;
                    if (shouldAuto) {
                        const custom = ($('#customProxy').val() || '').trim();
                        const proxies = [];
                        if (custom) proxies.push(custom);
                        if (CONFIG.PROXY_ENDPOINT) proxies.push(CONFIG.PROXY_ENDPOINT);
                        proxies.push('https://api.allorigins.win/raw?url=');
                        proxies.push('https://thingproxy.freeboard.io/fetch/');

                        const target = (CONFIG.API_URL || '').replace(/callback=\?/, '');
                        const ok = await attemptProxiesAndApply(proxies, target);
                        if (ok) return true; // 代理成功并应用数据
                    }
                } catch (e) {
                    console.warn('auto proxy attempt failed', e);
                }

                $('#historyList').html('<div class="loading-state"><p style="color: var(--danger);">获取数据失败。可尝试从本地导入JSON、使用 CORS 代理或粘贴JSON后应用。</p></div>');
                $('#manualFetchFallback').show();
                $('#pasteJson').val('');
                $('#importFile').val('');
                try { $('#importFile').focus(); } catch(e){}
                $('#pasteJson').focus();
                state.historyNumbers = [];
                return false;
            } finally {
                state.isLoading = false;
            }
        }

       

        // ========== 数据分析功能 ==========

        /**
         * 生成数据分析报告（含每项推荐与权重汇总）
         */
        function generateAnalysisReport() {
            // 优先使用界面值，否则默认 100（最大支持 500）
            let analysisPeriods = parseInt($('#analysisPeriods').val()) || 100;
            analysisPeriods = Math.min(analysisPeriods, state.historyNumbers.length, 500);
            $('#analysisPeriods').val(analysisPeriods);

            const recentData = state.historyNumbers.slice(0, analysisPeriods);

            // 预计算：数字热度、和值、奇偶比、大小比
            const digitFreq = getDigitFrequency(recentData);
            const digitAnalysis = digitFreq.map((count, digit) => ({
                digit: digit,
                count: count,
                frequency: ((count / (analysisPeriods * 3)) * 100).toFixed(2) + '%'
            })).sort((a, b) => b.count - a.count);

            const sumFreq = {};
            recentData.forEach(item => {
                const sum = calcSum(item.number);
                sumFreq[sum] = (sumFreq[sum] || 0) + 1;
            });
            const sumAnalysis = Object.entries(sumFreq)
                .map(([sum, count]) => ({ sum: parseInt(sum), count: count, frequency: ((count / analysisPeriods) * 100).toFixed(2) + '%' }))
                .sort((a, b) => b.count - a.count);

            const oddEvenFreq = {};
            recentData.forEach(item => {
                const oddEven = calcOddEven(item.number);
                oddEvenFreq[oddEven] = (oddEvenFreq[oddEven] || 0) + 1;
            });
            const oddEvenAnalysis = Object.entries(oddEvenFreq).map(([ratio, count]) => ({ ratio, count, frequency: ((count / analysisPeriods) * 100).toFixed(2) + '%' })).sort((a,b)=>b.count-a.count);

            const bigSmallFreq = {};
            recentData.forEach(item => {
                const bigSmall = calcBigSmall(item.number);
                bigSmallFreq[bigSmall] = (bigSmallFreq[bigSmall] || 0) + 1;
            });
            const bigSmallAnalysis = Object.entries(bigSmallFreq).map(([ratio, count]) => ({ ratio, count, frequency: ((count / analysisPeriods) * 100).toFixed(2) + '%' })).sort((a,b)=>b.count-a.count);

            // 替换之前的奖金判断策略：使用出现频率判断大众号（排列3奖金固定）
            const comboFreq = {};
            recentData.forEach(item => {
                const sorted = sortNumber(item.number);
                comboFreq[sorted] = (comboFreq[sorted] || 0) + 1;
            });
            const popularCombos = Object.entries(comboFreq).map(([number, count]) => ({ number, count })).sort((a,b)=>b.count-a.count).slice(0, 10);

            // 生成候选组合并计算特征（共120种）
            const combos = getAllZuxuan6Combos().map(c => {
                const freqSum = c.digits.reduce((s,d)=>s + digitFreq[d], 0);
                const occ = comboFreq[c.sorted] || 0;
                return Object.assign({}, c, { freqSum, occurrence: occ, isHotspot: isHotspot(c.number) });
            });

            // 推荐逻辑：每项输出最多3个推荐，并赋予权重 3/2/1; 同时保留和值（若存在）以便显示
            const recommendations = {};
            function addRec(section, arr) {
                recommendations[section] = arr.slice(0,3).map((item, i) => ({ number: item.number, score: 3 - i, sum: item.sum }));
            }

            // 1. 数字热度（优先使用高频数字之和）
            const digitCandidates = combos.filter(c => !c.isHotspot && !isRecentNumber(c.number, analysisPeriods)).sort((a,b)=>b.freqSum - a.freqSum);
            addRec('digitHeat', digitCandidates);

            // 2. 和值分布（优先和值高频，优先选择出现次数（occurrence）更高的组合，其次数字热度）
            const hotSums = sumAnalysis.slice(0,5).map(s=>s.sum);
            const sumCandidates = combos.filter(c => hotSums.includes(c.sum) && !c.isHotspot && !isRecentNumber(c.number, analysisPeriods)).sort((a,b)=> (b.occurrence - a.occurrence) || (b.freqSum - a.freqSum));
            addRec('sumTop', sumCandidates.length ? sumCandidates : digitCandidates);

            // 3. 奇偶比（优先符合最高频奇偶比）
            const topOddEven = oddEvenAnalysis.length ? oddEvenAnalysis[0].ratio : null;
            const oddEvenCandidates = topOddEven ? combos.filter(c=>c.oddEven === topOddEven && !c.isHotspot && !isRecentNumber(c.number, analysisPeriods)).sort((a,b)=>b.freqSum-a.freqSum) : [];
            addRec('oddEven', oddEvenCandidates.length ? oddEvenCandidates : digitCandidates);

            // 4. 大小比（优先符合最高频大小比）
            const topBigSmall = bigSmallAnalysis.length ? bigSmallAnalysis[0].ratio : null;
            const bigSmallCandidates = topBigSmall ? combos.filter(c=>c.bigSmall === topBigSmall && !c.isHotspot && !isRecentNumber(c.number, analysisPeriods)).sort((a,b)=>b.freqSum-a.freqSum) : [];
            addRec('bigSmall', bigSmallCandidates.length ? bigSmallCandidates : digitCandidates);

            // 5. 大众号分析（基于出现频率） -> 为避免拥挤，推荐与大众号数字重合较少的组合
            const popularDigits = new Set();
            popularCombos.forEach(p=> parseNumber(p.number).forEach(d=> popularDigits.add(d)));
            const popCandidates = combos.filter(c=> !c.isHotspot && !isRecentNumber(c.number, analysisPeriods)).map(c=>{
                const overlap = c.digits.filter(d=> popularDigits.has(d)).length;
                return Object.assign({}, c, { overlap });
            }).sort((a,b)=> a.overlap - b.overlap || b.freqSum - a.freqSum);
            addRec('popularAvoid', popCandidates.length ? popCandidates : digitCandidates);

            // ===== 验证并尽量修正各项推荐（基于每项推荐进行快速校验） =====
            const recommendationChecks = [];
            function getComboByNumber(num) { return combos.find(c=>c.number === num) || null; }

            // 频率阈值（取 top 20% 作为数字热度基准）
            const topFreqIndex = Math.max(0, Math.floor(combos.length * 0.2) - 1);
            const sortedByFreq = combos.slice().sort((a,b)=>b.freqSum - a.freqSum);
            const freqThreshold = (sortedByFreq[topFreqIndex] && sortedByFreq[topFreqIndex].freqSum) ? sortedByFreq[topFreqIndex].freqSum : 0;

            // 大众号重合阈值（取重合最小的 20%）
            const popularDigitsSet = new Set();
            popularCombos.forEach(p=> parseNumber(p.number).forEach(d=> popularDigitsSet.add(d)));
            const popPool = combos.map(c=> Object.assign({}, c, { overlap: c.digits.filter(d=> popularDigitsSet.has(d)).length }));
            const sortedByOverlap = popPool.slice().sort((a,b)=>a.overlap - b.overlap);
            const overlapThresholdIndex = Math.max(0, Math.floor(sortedByOverlap.length * 0.2) - 1);
            const overlapThreshold = (sortedByOverlap[overlapThresholdIndex] && sortedByOverlap[overlapThresholdIndex].overlap) ? sortedByOverlap[overlapThresholdIndex].overlap : 1;

            function validateAndFixSection(section, pool, validator) {
                const orig = recommendations[section] || [];
                const poolCopy = pool.slice();
                const out = [];
                for (let i=0;i<3;i++) {
                    const candidate = orig[i] ? getComboByNumber(orig[i].number) : null;
                    if (candidate && validator(candidate)) {
                        out.push({ number: candidate.number, score: orig[i].score, sum: candidate.sum, ok:true });
                        const idx = poolCopy.findIndex(p=>p.number===candidate.number);
                        if (idx !== -1) poolCopy.splice(idx,1);
                        continue;
                    }
                    const foundIndex = poolCopy.findIndex(c=> validator(c));
                    if (foundIndex !== -1) {
                        const f = poolCopy.splice(foundIndex,1)[0];
                        out.push({ number: f.number, score: 1, sum: f.sum, ok:true, replaced:true });
                    } else {
                        out.push({ number: orig[i] ? orig[i].number : '-', score: orig[i] ? orig[i].score : 0, sum: orig[i] ? orig[i].sum : null, ok:false });
                    }
                }
                recommendations[section] = out.map(o=> ({ number: o.number, score: o.score, sum: o.sum }) );
                const issues = out.filter(o=>!o.ok).map(o=> o.number + ' 不符合 ' + section + ' 要求');
                recommendationChecks.push({ section, ok: issues.length===0, issues, samples: out.map(o=>o.number) });
            }

            const validators = {
                digitHeat: c => c.freqSum >= freqThreshold,
                sumTop: c => hotSums.includes(c.sum),
                oddEven: c => (topOddEven ? c.oddEven === topOddEven : true),
                bigSmall: c => (topBigSmall ? c.bigSmall === topBigSmall : true),
                popularAvoid: c => c.overlap <= overlapThreshold
            };

            // 各节显示的中文名称映射
            const SECTION_LABELS = {
                digitHeat: '数字热度',
                sumTop: '和值分布',
                oddEven: '奇偶比',
                bigSmall: '大小比',
                popularAvoid: '大众号码避让'
            };

            // 执行校验并尝试修正不合格推荐
            validateAndFixSection('digitHeat', digitCandidates, validators.digitHeat);
            validateAndFixSection('sumTop', (sumCandidates.length ? sumCandidates : digitCandidates), validators.sumTop);
            validateAndFixSection('oddEven', (oddEvenCandidates.length ? oddEvenCandidates : digitCandidates), validators.oddEven);
            validateAndFixSection('bigSmall', (bigSmallCandidates.length ? bigSmallCandidates : digitCandidates), validators.bigSmall);
            validateAndFixSection('popularAvoid', (popCandidates.length ? popCandidates : digitCandidates), validators.popularAvoid);

            // 根据修正后的推荐重新汇总权重（包含和值）
            const aggregate = {};
            Object.entries(recommendations).forEach(([section, items])=>{
                items.forEach(it=>{
                    const combo = getComboByNumber(it.number);
                    const tie = (combo && combo.freqSum) ? combo.freqSum : 0;
                    aggregate[it.number] = aggregate[it.number] || { score: 0, breakdown: {}, sum: it.sum || null, tie: tie };
                    aggregate[it.number].score += it.score;
                    aggregate[it.number].breakdown[section] = it.score;
                    if (!aggregate[it.number].sum && it.sum) aggregate[it.number].sum = it.sum;
                    // 更新 tie 为最大出现频次（利于排序）
                    if (tie > (aggregate[it.number].tie || 0)) aggregate[it.number].tie = tie;
                });
            });

            // 最终推荐（按总分降序，若分数相同则按 tie 指标降序）
            const finalRecs = Object.entries(aggregate).map(([num, obj])=>({ number: num, score: obj.score, breakdown: obj.breakdown, sum: obj.sum, tie: obj.tie }))
                .sort((a,b)=> (b.score - a.score) || (b.tie - a.tie))
                .slice(0,3);

            // 生成HTML报告（含每项推荐与权重）
            let html = `
                <div class="analysis-content">
                <h3 style="color: var(--text-primary); margin-bottom: 12px; font-size: 1.1rem;">基于最近 ${analysisPeriods} 期数据的分析与推荐</h3>

                <div style="margin-bottom: 22px;">
                    <h4 style="color: var(--accent-blue); margin-bottom:8px;">1. 数字热度（按数字出现次数）</h4>
                    <div class="stats-grid" style="grid-template-columns: repeat(5, 1fr);">
                        ${digitAnalysis.map(item => `
                            <div class="stat-item">
                                <div class="value" style="font-size:1.5rem;">${item.digit}</div>
                                <div style="font-size:0.85rem;color:var(--text-secondary);margin-top:4px;">出现 ${item.count} 次</div>
                                <div style="font-size:0.75rem;color:var(--text-muted);">${item.frequency}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin-top:10px;">推荐号码： <span class="analysis-recommendation">${ (recommendations.digitHeat||[]).map(r=>`<span class="rec-item">${r.number}${r.sum?'<small style="margin-left:6px;color:var(--text-secondary);font-weight:400;">(和值 '+r.sum+')</small>':''} <small style="color:var(--text-secondary);"> (权重 ${r.score})</small></span>`).join('')}</span></div>
                </div>

                <div style="margin-bottom: 16px;">
                    <h4 style="color: var(--accent-blue); margin-bottom:8px;">2. 和值分布（Top）</h4>
                    <div class="sum-analysis-wrap" style="margin-bottom:8px;">
                        ${sumAnalysis.slice(0,8).map(s=>`<div style="background:var(--bg-secondary);padding:8px;border-radius:6px;">和值 ${s.sum}<br><small style="color:var(--text-secondary);">${s.count} 次</small></div>`).join('')}
                    </div>
                    <div>推荐号码： <span class="analysis-recommendation">${ (recommendations.sumTop||[]).map(r=>`<span class="rec-item">${r.number}${r.sum?'<small style="margin-left:6px;color:var(--text-secondary);font-weight:400;">(和值 '+r.sum+')</small>':''} <small style="color:var(--text-secondary);"> (权重 ${r.score})</small></span>`).join('')}</span></div>
                </div>

                <div style="display:grid;grid-template-columns:1fr 1fr;gap:18px;margin-bottom:18px;">
                    <div>
                        <h4 style="color: var(--accent-blue);margin-bottom:8px;">3. 奇偶比分布</h4>
                        <div style="background:var(--bg-secondary);padding:10px;border-radius:6px;">${oddEvenAnalysis.map(o=>`<div style="margin-bottom:6px;">${o.ratio}： ${o.count} 次 (${o.frequency})</div>`).join('')}</div>
                        <div style="margin-top:8px;">推荐号码： <span class="analysis-recommendation">${ (recommendations.oddEven||[]).map(r=>`<span class="rec-item">${r.number}${r.sum?'<small style="margin-left:6px;color:var(--text-secondary);font-weight:400;">(和值 '+r.sum+')</small>':''} <small style="color:var(--text-secondary);"> (权重 ${r.score})</small></span>`).join('')}</span></div>
                    </div>

                    <div>
                        <h4 style="color: var(--accent-blue);margin-bottom:8px;">4. 大小比分布</h4>
                        <div style="background:var(--bg-secondary);padding:10px;border-radius:6px;">${bigSmallAnalysis.map(b=>`<div style="margin-bottom:6px;">${b.ratio}： ${b.count} 次 (${b.frequency})</div>`).join('')}</div>
                        <div style="margin-top:8px;">推荐号码： <span class="analysis-recommendation">${ (recommendations.bigSmall||[]).map(r=>`<span class="rec-item">${r.number}${r.sum?'<small style="margin-left:6px;color:var(--text-secondary);font-weight:400;">(和值 '+r.sum+')</small>':''} <small style="color:var(--text-secondary);"> (权重 ${r.score})</small></span>`).join('')}</span></div>
                    </div>
                </div>

                <div style="margin-bottom:18px;">
                    <h4 style="color: var(--accent-blue);margin-bottom:8px;">5. 大众号（基于出现频率）</h4>
                    <div class="popular-wrap" style="margin-bottom:10px;">常见组合： ${popularCombos.map(p=>`<span style="font-family:monospace;color:var(--danger);margin-right:8px;">${p.number}(${p.count})</span>`).join('')}</div>
                    <div style="color:var(--text-secondary);margin-bottom:8px;">为避免过多人选择，建议优先选择与大众号数字重合较少的组合：</div>
                    <div>推荐号码： <span class="analysis-recommendation">${ (recommendations.popularAvoid||[]).map(r=>`<span class="rec-item">${r.number}${r.sum?'<small style="margin-left:6px;color:var(--text-secondary);font-weight:400;">(和值 '+r.sum+')</small>':''} <small style="color:var(--text-secondary);"> (权重 ${r.score})</small></span>`).join('')}</span></div>
                </div>

                <div style="padding:12px;background:var(--bg-secondary);border-radius:8px;">
                    <h4 style="margin-top:0;color:var(--accent-blue);">策略自检（快速校验各引擎输出约束）</h4>
                    <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px;">
                        ${recommendationChecks.map(rc=>`<div style="background:var(--bg-tertiary);padding:8px;border-radius:6px;color:${rc.ok? 'var(--success)': 'var(--warning)'};">${SECTION_LABELS[rc.section] || rc.section}： ${rc.ok? '通过' : '存在问题'}<br><small style="color:var(--text-secondary);">样例：${rc.samples.join(', ') || '-'}${rc.issues.length ? ('；问题：' + rc.issues.join('，')) : ''}</small></div>`).join('')}
                    </div>
                    <h4 style="margin-top:0;color:var(--accent-blue);">综合权重汇总（最终推荐）</h4>
                    <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;">
                        ${finalRecs.map(r=>`<div style="background:var(--bg-tertiary);padding:8px;border-radius:6px;font-family:monospace;color:var(--accent-cyan);">${r.number}${r.sum? '（和值 '+r.sum+'）':''}（总权 ${r.score}）<br><small style="color:var(--text-secondary);">${Object.entries(r.breakdown||{}).map(([k,v])=> (SECTION_LABELS[k] || k) + ':' + v).join('，')}</small></div>`).join('')}
                    </div>
                </div>
            </div>`;

            $('#analysisContent').html(html);
            $('#analysisSection').show();

            // 返回最终推荐以便其它逻辑（如策略引擎）使用
            return finalRecs.map(r=>r.number);
        }

        // ========== 策略引擎 ==========

        /**
         * 策略A：数学均匀分布引擎
         *
         * 核心逻辑：
         * 1. 在和值分布上均匀（低、中、高）
         * 2. 在跨度分布上均匀（小、中、大）
         * 3. 避免等差数列和明显模式
         * 4. 三注之间保持差异化
         */
        function strategyMathUniform(options) {
            const { strictMode, aggressiveMode, avoidPeriods } = options;
            const results = [];
            const usedSorted = new Set();

            // 获取需要避开的数字（严格模式）
            const avoidDigits = strictMode ? getAvoidDigits(avoidPeriods) : new Set();

            // 目标：生成三注在和值区间上分散的号码
            // 和值范围：0+1+2=3 到 7+8+9=24，中间值约13-14
            // 分为：低(3-10)、中(11-16)、高(17-24)
            const sumRanges = [
                { min: 3, max: 10, label: '低和值' },
                { min: 11, max: 16, label: '中和值' },
                { min: 17, max: 24, label: '高和值' }
            ];

            for (let i = 0; i < 3; i++) {
                const targetRange = sumRanges[i];
                let attempts = 0;
                let found = false;

                while (!found && attempts < 500) {
                    attempts++;
                    const num = generateRandomZuxuan6(avoidDigits, aggressiveMode);
                    if (!num) continue;

                    const sum = calcSum(num);
                    const sorted = sortNumber(num);

                    // 检查条件
                    if (sum >= targetRange.min && sum <= targetRange.max &&
                        !usedSorted.has(sorted) &&
                        !isHotspot(num) &&
                        !isArithmeticSequence(num) &&
                        !isRecentNumber(num, avoidPeriods)) {

                        results.push({
                            number: num,
                            analysis: generateAnalysis(num, 'math', targetRange.label)
                        });
                        usedSorted.add(sorted);
                        found = true;
                    }
                }

                // 如果特定范围找不到，放宽条件
                if (!found) {
                    let fallbackAttempts = 0;
                    while (!found && fallbackAttempts < 200) {
                        fallbackAttempts++;
                        const num = generateRandomZuxuan6(aggressiveMode ? new Set() : avoidDigits, aggressiveMode);
                        if (!num) continue;

                        const sorted = sortNumber(num);
                        if (!usedSorted.has(sorted) && !isHotspot(num) && !isRecentNumber(num, avoidPeriods)) {
                            results.push({
                                number: num,
                                analysis: generateAnalysis(num, 'math', '均衡分布')
                            });
                            usedSorted.add(sorted);
                            found = true;
                        }
                    }
                }
            }

            return results;
        }

        /**
         * 策略B：追热避冷（顺势而为）
         *
         * 核心逻辑：
         * 1. 找出近期热码（出现频率最高的2-3个数字）
         * 2. 找出近期热和值区间
         * 3. 将热码作为核心，组合生成号码
         * 4. 确保和值落在热区
         */
        function strategyHotTrend(options) {
            const { strictMode, aggressiveMode, avoidPeriods, analysisPeriods } = options;
            const results = [];
            const usedSorted = new Set();
            const recentData = state.historyNumbers.slice(0, analysisPeriods);
            
            // 获取需要避开的数字（严格模式）
            const avoidDigits = strictMode ? getAvoidDigits(avoidPeriods) : new Set();
            
            // 1. 找出热码（出现频率最高的3个数字）
            const digitFreq = getDigitFrequency(recentData, analysisPeriods);
            const hotDigits = digitFreq
                .map((count, digit) => ({ digit, count }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 3)
                .map(item => item.digit);
            
            // 2. 找出热和值区间（出现频率最高的5个和值）
            const sumFreq = {};
            recentData.forEach(item => {
                const sum = calcSum(item.number);
                sumFreq[sum] = (sumFreq[sum] || 0) + 1;
            });
            const hotSums = Object.entries(sumFreq)
                .map(([sum, count]) => ({ sum: parseInt(sum), count }))
                .sort((a, b) => b.count - a.count)
                .slice(0, 5)
                .map(item => item.sum);
            
            // 3. 生成号码，包含至少1个热码，和值为热和值
            for (let i = 0; i < 3; i++) {
                let attempts = 0;
                let found = false;
                
                while (!found && attempts < 500) {
                    attempts++;
                    
                    // 确保包含至少一个热码
                    let digits;
                    do {
                        digits = [];
                        // 先选一个热码
                        digits.push(hotDigits[Math.floor(Math.random() * hotDigits.length)]);
                        // 再选两个随机数字（可以是热码）
                        while (digits.length < 3) {
                            const d = Math.floor(Math.random() * 10);
                            if (!digits.includes(d) && !avoidDigits.has(d)) {
                                digits.push(d);
                            }
                        }
                    } while (digits.length < 3);
                    
                    // 打乱顺序生成号码
                    const shuffled = [...digits].sort(() => Math.random() - 0.5);
                    const num = shuffled.join('');
                    const sorted = sortNumber(num);
                    const sum = calcSum(num);
                    
                    // 检查条件：包含热码，和值为热和值，不是热点组合，不是近期号码
                    if (hotSums.includes(sum) &&
                        !usedSorted.has(sorted) &&
                        !isHotspot(num) &&
                        !isRecentNumber(num, avoidPeriods)) {
                        
                        results.push({
                            number: num,
                            analysis: generateAnalysis(num, 'hot', '追热避冷')
                        });
                        usedSorted.add(sorted);
                        found = true;
                    }
                }
                
                // 备用方案：放宽条件
                if (!found) {
                    let fallbackAttempts = 0;
                    while (!found && fallbackAttempts < 200) {
                        fallbackAttempts++;
                        const num = generateRandomZuxuan6(aggressiveMode ? new Set() : avoidDigits, aggressiveMode);
                        if (!num) continue;
                        
                        const sorted = sortNumber(num);
                        if (!usedSorted.has(sorted) && !isHotspot(num) && !isRecentNumber(num, avoidPeriods)) {
                            results.push({
                                number: num,
                                analysis: generateAnalysis(num, 'hot', '追热避冷（放宽条件）')
                            });
                            usedSorted.add(sorted);
                            found = true;
                        }
                    }
                }
            }
            
            return results;
        }

        /**
         * 策略C：赌冷回归（逆势博弈）
         *
         * 核心逻辑：
         * 1. 找出长期遗漏的冷码
         * 2. 找出近期出现最少的和值
         * 3. 大胆选用1-2个顶级冷码，搭配中性码组合
         */
        function strategyColdReturn(options) {
            const { strictMode, aggressiveMode, avoidPeriods, analysisPeriods } = options;
            const results = [];
            const usedSorted = new Set();
            const recentData = state.historyNumbers.slice(0, analysisPeriods);
            
            // 获取需要避开的数字（严格模式）
            const avoidDigits = strictMode ? getAvoidDigits(avoidPeriods) : new Set();
            
            // 1. 找出冷码（出现频率最低的3个数字）
            const digitFreq = getDigitFrequency(recentData, analysisPeriods);
            const coldDigits = digitFreq
                .map((count, digit) => ({ digit, count }))
                .sort((a, b) => a.count - b.count)
                .slice(0, 3)
                .map(item => item.digit);
            
            // 2. 找出冷和值（出现频率最低的5个和值）
            const sumFreq = {};
            recentData.forEach(item => {
                const sum = calcSum(item.number);
                sumFreq[sum] = (sumFreq[sum] || 0) + 1;
            });
            const coldSums = Object.entries(sumFreq)
                .map(([sum, count]) => ({ sum: parseInt(sum), count }))
                .sort((a, b) => a.count - b.count)
                .slice(0, 5)
                .map(item => item.sum);
            
            // 3. 生成号码，包含至少1个冷码，和值为冷和值
            for (let i = 0; i < 3; i++) {
                let attempts = 0;
                let found = false;
                
                while (!found && attempts < 500) {
                    attempts++;
                    
                    // 确保包含至少一个冷码
                    let digits;
                    do {
                        digits = [];
                        // 先选一个冷码
                        digits.push(coldDigits[Math.floor(Math.random() * coldDigits.length)]);
                        // 再选两个随机数字（可以是冷码）
                        while (digits.length < 3) {
                            const d = Math.floor(Math.random() * 10);
                            if (!digits.includes(d) && !avoidDigits.has(d)) {
                                digits.push(d);
                            }
                        }
                    } while (digits.length < 3);
                    
                    // 打乱顺序生成号码
                    const shuffled = [...digits].sort(() => Math.random() - 0.5);
                    const num = shuffled.join('');
                    const sorted = sortNumber(num);
                    const sum = calcSum(num);
                    
                    // 检查条件：包含冷码，和值为冷和值，不是热点组合，不是近期号码
                    if (coldSums.includes(sum) &&
                        !usedSorted.has(sorted) &&
                        !isHotspot(num) &&
                        !isRecentNumber(num, avoidPeriods)) {
                        
                        results.push({
                            number: num,
                            analysis: generateAnalysis(num, 'coldreturn', '赌冷回归')
                        });
                        usedSorted.add(sorted);
                        found = true;
                    }
                }
                
                // 备用方案：放宽条件
                if (!found) {
                    let fallbackAttempts = 0;
                    while (!found && fallbackAttempts < 200) {
                        fallbackAttempts++;
                        const num = generateRandomZuxuan6(aggressiveMode ? new Set() : avoidDigits, aggressiveMode);
                        if (!num) continue;
                        
                        const sorted = sortNumber(num);
                        if (!usedSorted.has(sorted) && !isHotspot(num) && !isRecentNumber(num, avoidPeriods)) {
                            results.push({
                                number: num,
                                analysis: generateAnalysis(num, 'coldreturn', '赌冷回归（放宽条件）')
                            });
                            usedSorted.add(sorted);
                            found = true;
                        }
                    }
                }
            }
            
            return results;
        }

        /**
         * 策略D：精确逆向（利用奖金数据）
         *
         * 核心逻辑：
         * 1. 找出导致组选6奖金最低的号码（大众号）
         * 2. 避开这些大众号
         * 3. 避开与大众号数字组合高度相似的号码
         * 4. 生成与大众号特征相反的号码
         */
        function strategyPrecisionReverse(options) {
            const { strictMode, aggressiveMode, avoidPeriods, analysisPeriods } = options;
            const results = [];
            const usedSorted = new Set();
            const recentData = state.historyNumbers.slice(0, analysisPeriods);
            
            // 获取需要避开的数字（严格模式）
            const avoidDigits = strictMode ? getAvoidDigits(avoidPeriods) : new Set();
            
            // 1. 找出大众号（基于出现频率；排列3奖金固定，不再以奖金判断）
            const comboFreq = {};
            recentData.filter(item => isZuxuan6(item.number)).forEach(it => {
                const s = sortNumber(it.number);
                comboFreq[s] = (comboFreq[s] || 0) + 1;
            });
            const popularNumbers = Object.entries(comboFreq).sort((a,b)=>b[1]-a[1]).slice(0,10).map(([num])=>num);
            
            // 2. 找出大众号中频繁出现的数字（需要避开的数字）
            const popularDigits = new Set();
            popularNumbers.forEach(num => {
                parseNumber(num).forEach(d => popularDigits.add(d));
            });
            
            // 3. 生成号码，避开大众号及其相似号码
            for (let i = 0; i < 3; i++) {
                let attempts = 0;
                let found = false;
                
                while (!found && attempts < 500) {
                    attempts++;
                    
                    // 生成号码，尽量避开大众号数字
                    let digits;
                    do {
                        digits = [];
                        while (digits.length < 3) {
                            const d = Math.floor(Math.random() * 10);
                            if (!digits.includes(d) && !avoidDigits.has(d)) {
                                digits.push(d);
                            }
                        }
                    } while (digits.length < 3);
                    
                    const num = digits.join('');
                    const sorted = sortNumber(num);
                    const numDigits = new Set(digits);
                    
                    // 检查是否与大众号高度相似（包含2个以上相同数字）
                    let isSimilar = false;
                    for (const popularNum of popularNumbers) {
                        const popularNumDigits = new Set(parseNumber(popularNum));
                        const intersection = [...numDigits].filter(d => popularNumDigits.has(d));
                        if (intersection.length >= 2) {
                            isSimilar = true;
                            break;
                        }
                    }
                    
                    // 检查条件：不是大众号，不与大众号高度相似，不是热点组合，不是近期号码
                    if (!isSimilar &&
                        !popularNumbers.includes(num) &&
                        !usedSorted.has(sorted) &&
                        !isHotspot(num) &&
                        !isRecentNumber(num, avoidPeriods)) {
                        
                        results.push({
                            number: num,
                            analysis: generateAnalysis(num, 'precision', '精确逆向')
                        });
                        usedSorted.add(sorted);
                        found = true;
                    }
                }
                
                // 备用方案：放宽条件
                if (!found) {
                    let fallbackAttempts = 0;
                    while (!found && fallbackAttempts < 200) {
                        fallbackAttempts++;
                        const num = generateRandomZuxuan6(aggressiveMode ? new Set() : avoidDigits, aggressiveMode);
                        if (!num) continue;
                        
                        const sorted = sortNumber(num);
                        if (!usedSorted.has(sorted) && !isHotspot(num) && !isRecentNumber(num, avoidPeriods)) {
                            results.push({
                                number: num,
                                analysis: generateAnalysis(num, 'precision', '精确逆向（放宽条件）')
                            });
                            usedSorted.add(sorted);
                            found = true;
                        }
                    }
                }
            }
            
            return results;
        }

        /**
         * 策略B：文化避开策略引擎
         *
         * 核心逻辑：
         * 1. 主动避开吉利数字 6、8、9
         * 2. 优先使用"中性"数字 0、2、3、5、7
         * 3. 可包含适量的"4"（激进模式）
         * 4. 生成视觉上"不美观"的组合
         */
        function strategyCultureAvoid(options) {
            const { strictMode, aggressiveMode, avoidPeriods } = options;
            const results = [];
            const usedSorted = new Set();

            // 文化避开数字池
            // 优先数字：0, 1, 2, 3, 5, 7（不包含6、8、9）
            // 激进模式额外包含：4
            let preferredDigits = [0, 1, 2, 3, 5, 7];
            if (aggressiveMode) {
                preferredDigits.push(4);
            }

            // 获取需要避开的数字（严格模式）
            const avoidDigits = strictMode ? getAvoidDigits(avoidPeriods) : new Set();

            // 从优先数字中移除需要避开的
            const availableDigits = preferredDigits.filter(d => !avoidDigits.has(d));

            for (let i = 0; i < 3; i++) {
                let attempts = 0;
                let found = false;

                while (!found && attempts < 500) {
                    attempts++;

                    // 从可用数字中随机选3个不同的
                    if (availableDigits.length < 3) {
                        // 可用数字不足，放宽限制
                        break;
                    }

                    const shuffled = [...availableDigits].sort(() => Math.random() - 0.5);
                    const selected = shuffled.slice(0, 3);
                    const num = selected.join('');
                    const sorted = sortNumber(num);

                    if (!usedSorted.has(sorted) &&
                        !isHotspot(num) &&
                        !isRecentNumber(num, avoidPeriods)) {

                        results.push({
                            number: num,
                            analysis: generateAnalysis(num, 'culture')
                        });
                        usedSorted.add(sorted);
                        found = true;
                    }
                }

                // 备用方案：放宽条件
                if (!found) {
                    let fallbackAttempts = 0;
                    const fallbackDigits = aggressiveMode ? [0,1,2,3,4,5,7] : [0,1,2,3,5,7];

                    while (!found && fallbackAttempts < 200) {
                        fallbackAttempts++;
                        const shuffled = [...fallbackDigits].sort(() => Math.random() - 0.5);
                        const selected = shuffled.slice(0, 3);
                        const num = selected.join('');
                        const sorted = sortNumber(num);

                        if (!usedSorted.has(sorted) && !isHotspot(num)) {
                            results.push({
                                number: num,
                                analysis: generateAnalysis(num, 'culture')
                            });
                            usedSorted.add(sorted);
                            found = true;
                        }
                    }
                }
            }

            return results;
        }

        /**
         * 策略C：近期热号冷僻策略引擎
         *
         * 核心逻辑：
         * 1. 分析近期开奖号码中各数字出现频率
         * 2. 优先选择出现频率最低的"冷号"
         * 3. 最大程度避开热门数字
         */
        function strategyColdNumbers(options) {
            const { strictMode, aggressiveMode, avoidPeriods } = options;
            const results = [];
            const usedSorted = new Set();

            // 计算数字频率
            const freq = getDigitFrequency(state.historyNumbers, avoidPeriods);

            // 按频率排序（升序），获取冷号
            const sortedDigits = Array.from({length: 10}, (_, i) => i)
                .sort((a, b) => freq[a] - freq[b]);

            // 获取最冷的数字（频率最低的前6个）
            let coldDigits = sortedDigits.slice(0, 7);

            // 严格模式：进一步过滤
            if (strictMode) {
                const avoidDigits = getAvoidDigits(avoidPeriods);
                coldDigits = coldDigits.filter(d => !avoidDigits.has(d));
            }

            // 非激进模式：移除4
            if (!aggressiveMode) {
                coldDigits = coldDigits.filter(d => d !== 4);
            }

            for (let i = 0; i < 3; i++) {
                let attempts = 0;
                let found = false;

                while (!found && attempts < 500) {
                    attempts++;

                    // 优先从冷号中选择
                    let pool = coldDigits.length >= 3 ? coldDigits : sortedDigits.slice(0, 7);
                    if (!aggressiveMode) {
                        pool = pool.filter(d => d !== 4);
                    }

                    if (pool.length < 3) {
                        pool = [0,1,2,3,5,6,7,8,9];
                    }

                    const shuffled = [...pool].sort(() => Math.random() - 0.5);
                    const selected = shuffled.slice(0, 3);

                    // 确保三个数字不同
                    if (new Set(selected).size !== 3) continue;

                    const num = selected.join('');
                    const sorted = sortNumber(num);

                    if (!usedSorted.has(sorted) &&
                        !isHotspot(num) &&
                        !isRecentNumber(num, avoidPeriods)) {

                        results.push({
                            number: num,
                            analysis: generateAnalysis(num, 'cold', freq)
                        });
                        usedSorted.add(sorted);
                        found = true;
                    }
                }

                // 备用方案
                if (!found) {
                    let fallbackAttempts = 0;
                    while (!found && fallbackAttempts < 200) {
                        fallbackAttempts++;
                        const num = generateRandomZuxuan6(new Set(), aggressiveMode);
                        if (!num) continue;

                        const sorted = sortNumber(num);
                        if (!usedSorted.has(sorted) && !isHotspot(num)) {
                            results.push({
                                number: num,
                                analysis: generateAnalysis(num, 'cold', freq)
                            });
                            usedSorted.add(sorted);
                            found = true;
                        }
                    }
                }
            }

            return results;
        }

        /**
         * 生成随机组选6号码
         */
        function generateRandomZuxuan6(avoidDigits = new Set(), allowFour = false) {
            let pool = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].filter(d => !avoidDigits.has(d));
            if (!allowFour) {
                pool = pool.filter(d => d !== 4);
            }

            if (pool.length < 3) return null;

            const shuffled = pool.sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, 3);
            return selected.join('');
        }

        /**
         * 获取需要避开的数字（严格模式）
         */
        function getAvoidDigits(periods) {
            const digits = new Set();
            state.historyNumbers.slice(0, periods).forEach(item => {
                parseNumber(item.number).forEach(d => digits.add(d));
            });
            return digits;
        }

        /**
         * 生成所有可能的组选6（3个不同数字，不重复，按升序表示，共 C(10,3)=120 种）
         */
        function getAllZuxuan6Combos() {
            const combos = [];
            for (let a = 0; a <= 7; a++) {
                for (let b = a + 1; b <= 8; b++) {
                    for (let c = b + 1; c <= 9; c++) {
                        const digits = [a, b, c];
                        const num = digits.join('');
                        combos.push({
                            number: num,
                            digits: digits,
                            sum: digits.reduce((s, d) => s + d, 0),
                            span: Math.max(...digits) - Math.min(...digits),
                            oddEven: `${digits.filter(d => d % 2 === 1).length}:${3 - digits.filter(d => d % 2 === 1).length}`,
                            bigSmall: `${digits.filter(d => d >= 5).length}:${3 - digits.filter(d => d >= 5).length}`,
                            sorted: sortNumber(num)
                        });
                    }
                }
            }
            return combos;
        }

        /**
         * 检查是否与近期号码重复
         */
        function isRecentNumber(num, periods) {
            const sorted = sortNumber(num);
            let p = parseInt(periods);
            if (!Number.isInteger(p) || p <= 0) {
                // 若未传入有效期数，默认检查最近 up to 500 条或当前可用的最大期数
                p = Math.min(500, state.historyNumbers.length);
            }
            p = Math.min(p, state.historyNumbers.length);
            return state.historyNumbers.slice(0, p).some(item =>
                sortNumber(item.number) === sorted
            );
        }

        /**
         * 生成策略分析文本
         */
        function generateAnalysis(num, strategy, extra = null) {
            const sum = calcSum(num);
            const span = calcSpan(num);
            const oddEven = calcOddEven(num);
            const bigSmall = calcBigSmall(num);
            const digits = parseNumber(num);

            let baseAnalysis = `和值<span class="highlight">${sum}</span>，跨度<span class="highlight">${span}</span>，奇偶比${oddEven}，大小比${bigSmall}。`;

            switch (strategy) {
                case 'math':
                    baseAnalysis += ` 此组合属于<span class="highlight">${extra || '均衡分布'}</span>区间，非等差数列，数字分布均匀。`;
                    break;
                case 'culture':
                    const hasLucky = digits.some(d => [6, 8, 9].includes(d));
                    if (!hasLucky) {
                        baseAnalysis += ` 完全避开吉利数字6、8、9，使用<span class="highlight">中性数字</span>组合。`;
                    } else {
                        baseAnalysis += ` 以中性数字为主，视觉上<span class="highlight">"不讨喜"</span>，避开大众偏好。`;
                    }
                    break;
                case 'cold':
                    if (extra) {
                        const coldInfo = digits.map(d => `${d}(频${extra[d]}次)`).join('、');
                        baseAnalysis += ` 使用冷号：${coldInfo}，<span class="highlight">近期低频</span>组合。`;
                    }
                    break;
            }

            return baseAnalysis;
        }

        /**
         * 主生成函数
         */
        function generateNumbers(strategy) {
            // 读取并规范输入值，避免 NaN 导致避开最近期数功能失效
            const rawAnalysis = parseInt($('#analysisPeriods').val());
            const analysisPeriods = Number.isInteger(rawAnalysis) && rawAnalysis > 0 ? Math.min(rawAnalysis, state.historyNumbers.length, 500) : Math.min(500, state.historyNumbers.length);
            const rawAvoid = parseInt($('#avoidPeriods').val());
            // 若 avoidPeriods 未设置或非法，默认与 analysisPeriods 保持一致
            const avoidPeriods = Number.isInteger(rawAvoid) && rawAvoid > 0 ? Math.min(rawAvoid, state.historyNumbers.length) : analysisPeriods;

            const options = {
                strictMode: $('#strictMode').is(':checked'),
                aggressiveMode: $('#aggressiveMode').is(':checked'),
                avoidPeriods: avoidPeriods,
                analysisPeriods: analysisPeriods
            };

            switch (strategy) {
                case 'math':
                    return strategyMathUniform(options);
                case 'culture':
                    return strategyCultureAvoid(options);
                case 'cold':
                    return strategyColdNumbers(options);
                case 'hot':
                    return strategyHotTrend(options);
                case 'coldreturn':
                    return strategyColdReturn(options);
                case 'precision':
                    return strategyPrecisionReverse(options);
                default:
                    return strategyMathUniform(options);
            }
        }

        // ========== UI 渲染函数 ==========

        /**
         * 渲染历史记录列表
         */
        function renderHistoryList() {
            const $list = $('#historyList');

            if (state.historyNumbers.length === 0) {
                $list.html('<div class="loading-state"><p>暂无数据</p></div>');
                return;
            }

            let html = '';
            state.historyNumbers.forEach((item, index) => {
                html += `
                    <div class="history-item" data-index="${index}">
                        <div>
                            <span class="num">${item.number}</span>
                            <span class="date">${item.date} 第${item.period}期</span>
                        </div>
                        <button class="delete-btn" data-index="${index}">×</button>
                    </div>
                `;
            });

            $list.html(html);
        }

        /**
         * 渲染热点号码
         */
        function renderHotspots() {
            const displayHotspots = [
                '123', '456', '789', '147', '258', '369',
                '666', '888', '168', '268', '518', '618',
                '520', '521', '741', '852', '963', '159'
            ];

            let html = '';
            displayHotspots.forEach(num => {
                html += `<span class="hotspot-tag">${num}</span>`;
            });

            $('#hotspotGrid').html(html);
        }

        /**
         * 渲染统计信息
         */
        function renderStats() {
            const periods = parseInt($('#avoidPeriods').val());
            const freq = getDigitFrequency(state.historyNumbers, periods);

            const digitsSorted = Array.from({length:10}, (_, i) => ({ digit: i, freq: freq[i] }))
                .sort((a,b) => b.freq - a.freq);

            const hotTop = digitsSorted.slice(0, 3);
            const coldTop = digitsSorted.slice(-3).reverse();

            const html = `
                <div class="stat-item">
                    <div class="value">${hotTop.map(d=>d.digit).join(', ')}</div>
                    <div class="label">热号（Top 3）</div>
                    <div style="font-size:0.75rem;color:var(--text-secondary);margin-top:6px;">${hotTop.map(d=>d.freq + '次').join(' · ')}</div>
                </div>
                <div class="stat-item">
                    <div class="value">${coldTop.map(d=>d.digit).join(', ')}</div>
                    <div class="label">冷号（Top 3）</div>
                    <div style="font-size:0.75rem;color:var(--text-secondary);margin-top:6px;">${coldTop.map(d=>d.freq + '次').join(' · ')}</div>
                </div>
            `;

            $('#statsGrid').html(html);
        }

        /* ========== 完整开奖记录表格功能 ========== */
        function setupFullHistoryTable() {
            const pageSize = 50;
            state.fullTable = state.fullTable || {};
            state.fullTable.pageSize = pageSize;
            state.fullTable.currentPage = 0;
            state.fullTable.totalPages = Math.ceil((state.historyNumbers || []).length / pageSize);
            state.fullTable.loading = false;

            const $tbody = $('#fullHistoryTable tbody');
            $tbody.html('');

            if ((state.historyNumbers || []).length === 0) {
                $tbody.html('<tr><td colspan="11" style="text-align:center;color:var(--text-secondary);padding:20px;">暂无数据</td></tr>');
                $('#loadMoreBtn').prop('disabled', true).text('暂无数据');
                return;
            }

            $('#loadMoreBtn').prop('disabled', false).text('加载更多');
            // 加载第一页
            loadNextTablePage();
        }

        function loadNextTablePage() {
            if (!state.fullTable) setupFullHistoryTable();
            if (state.fullTable.loading) return;
            if (state.fullTable.currentPage >= state.fullTable.totalPages) return;

            state.fullTable.loading = true;
            $('#loadMoreBtn').text('加载中...').prop('disabled', true);

            const start = state.fullTable.currentPage * state.fullTable.pageSize;
            const end = start + state.fullTable.pageSize;
            const rows = (state.historyNumbers || []).slice(start, end);
            const $tbody = $('#fullHistoryTable tbody');

            rows.forEach(item => {
                const num = item.rawResult || (item.number || '').split('').join(' ');
                const zhixuanCount = item.prizeZhixuan ? item.prizeZhixuan.stakeCount : '-';
                const zhixuanAmt = item.prizeZhixuan ? item.prizeZhixuan.stakeAmount : '-';
                const z3Count = item.prizeZuxuan3 ? item.prizeZuxuan3.stakeCount : '-';
                const z3Amt = item.prizeZuxuan3 ? item.prizeZuxuan3.stakeAmount : '-';
                const z6Count = item.prizeZuxuan6 ? item.prizeZuxuan6.stakeCount : '-';
                const z6Amt = item.prizeZuxuan6 ? item.prizeZuxuan6.stakeAmount : '-';
                const sale = item.totalSaleAmount || '-';
                const pdf = item.drawPdfUrl ? `<a href="${item.drawPdfUrl}" target="_blank">公告</a>` : (item.lotteryNotice ? '有' : '-');

                $tbody.append(`
                    <tr>
                        <td style="font-family: monospace;">${item.period}</td>
                        <td>${item.date}</td>
                        <td style="font-family: monospace; color: var(--accent-cyan); font-weight:600;">${num}</td>
                        <td>${zhixuanCount}</td>
                        <td>${zhixuanAmt}</td>
                        <td>${z3Count}</td>
                        <td>${z3Amt}</td>
                        <td>${z6Count}</td>
                        <td>${z6Amt}</td>
                        <td>${sale}</td>
                        <td>${pdf}</td>
                    </tr>
                `);
            });

            state.fullTable.currentPage++;
            state.fullTable.loading = false;

            const loadedAll = state.fullTable.currentPage >= state.fullTable.totalPages;
            $('#loadMoreBtn').text(loadedAll ? '已加载全部' : '加载更多').prop('disabled', loadedAll);
        }

        // 滑动到底部自动加载下一页（移动端友好）
        $('#fullTableContainer').on('scroll', function() {
            const $el = $(this);
            if ($el[0].scrollHeight - $el.scrollTop() - $el.outerHeight() < 120) {
                loadNextTablePage();
            }
        });

        // 加载更多按钮
        $('#loadMoreBtn').on('click', function() {
            loadNextTablePage();
        });

        /* ========== 手动粘贴与导出为单文件 HTML 的工具函数 ========== */
        function normalizeApiItem(item) {
            // 支持 API 原始项或已标准化的项
            const rawResult = item.lotteryDrawResult || item.rawResult || '';
            const compact = (rawResult || (item.number || '')).toString().replace(/\s+/g, '');

            const getPrizeInfo = (prizeList, levelName, groupKey) => {
                if (!prizeList || !Array.isArray(prizeList)) return { stakeCount: '0', stakeAmount: '0' };
                const prize = prizeList.find(p => p.prizeLevel === levelName || p.group === groupKey) || prizeList.find(p => p.group === groupKey) || {};
                return {
                    stakeCount: (prize.stakeCount !== undefined) ? String(prize.stakeCount) : (prize.stakeCount || '0'),
                    stakeAmount: (prize.stakeAmountFormat || prize.stakeAmount || prize.stakeAmount || '0')
                };
            };

            return {
                number: compact,
                rawResult: rawResult || compact.split('').join(' '),
                date: item.lotteryDrawTime || item.date || '',
                period: item.lotteryDrawNum || item.period || '',
                prizeZhixuan: getPrizeInfo(item.prizeLevelList || item.prizeLevelList || [], '直选', '10'),
                prizeZuxuan3: getPrizeInfo(item.prizeLevelList || item.prizeLevelList || [], '组选3', '20'),
                prizeZuxuan6: getPrizeInfo(item.prizeLevelList || item.prizeLevelList || [], '组选6', '30'),
                totalSaleAmount: item.totalSaleAmount || item.totalSaleAmountFormat || item.totalSale || '-',
                drawPdfUrl: item.drawPdfUrl || item.pdf || '',
                lotteryNotice: item.lotteryNotice || 0
            };
        }

        function applyPastedData(saveAndDownload = false) {
            const raw = $('#pasteJson').val().trim();
            if (!raw) { showError('请先粘贴JSON数据'); return; }

            let parsed = null;
            try {
                parsed = JSON.parse(raw);
            } catch (e) {
                showError('JSON 解析失败：' + e.message);
                return;
            }

            let list = null;
            if (Array.isArray(parsed)) {
                list = parsed;
            } else if (parsed.value && Array.isArray(parsed.value.list)) {
                list = parsed.value.list;
            } else if (Array.isArray(parsed.list)) {
                list = parsed.list;
            } else if (parsed.data && Array.isArray(parsed.data.list)) {
                list = parsed.data.list;
            } else {
                showError('无法识别 JSON 结构，请粘贴接口返回的完整 JSON 或其中的 list 数组。');
                return;
            }

            const normalized = list.map(normalizeApiItem).filter(i => i && i.period && i.number);
            if (normalized.length === 0) {
                showError('未从粘贴的数据中解析到有效记录');
                return;
            }

            // 写入 state 并刷新界面
            state.historyNumbers = normalized.sort((a, b) => parseInt(b.period || 0) - parseInt(a.period || 0));
            renderHistoryList();
            renderStats();
            // 记录用户分析期数意图并在界面上设置（最多500期）并先生成策略结果
            state.requestedAnalysisTarget = parseInt($('#analysisPeriods').val()) || 100;
            $('#analysisPeriods').val(Math.min(state.requestedAnalysisTarget, state.historyNumbers.length, 500));
            generateAnalysisReport();
            const initResults = generateNumbers(state.selectedStrategy);
            renderResults(initResults);
            setupFullHistoryTable();
            $('#manualFetchFallback').hide();
            // 尝试保存到 localStorage，便于下次打开时恢复（若浏览器允许）
            try {
                localStorage.setItem('anti_crowd_history', JSON.stringify(state.historyNumbers));
                showError('已应用粘贴数据并保存到本地（' + normalized.length + ' 条）');
            } catch (e) {
                showError('已应用粘贴数据（' + normalized.length + ' 条）');
            }

            if (saveAndDownload) {
                generateSelfContainedHTML();
            }
        }

        function generateSelfContainedHTML() {
            // 在当前页面 HTML 中注入 PRELOADED_HISTORY 数据并作为单文件下载
            try {
                const html = '<!doctype html>\n' + document.documentElement.outerHTML;
                const dataScript = `<script>window.PRELOADED_HISTORY = ${JSON.stringify(state.historyNumbers)};<\/script>`;
                const injected = html.replace('</body>', dataScript + '\n</body>');
                const blob = new Blob([injected], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
                a.download = `anti-crowd-lottery_${ts}.html`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                showError('已生成单文件 HTML，下载应已开始');
            } catch (e) {
                showError('生成文件失败：' + e.message);
            }
        }

        /**
         * 渲染生成结果
         */
        function renderResults(results) {
            if (results.length === 0) {
                showError('生成失败，请调整参数后重试');
                return;
            }

            let html = '';
            results.forEach((item, index) => {
                html += `
                    <article class="result-card">
                        <p class="label">第 ${index + 1} 注</p>
                        <p class="number">${item.number}</p>
                        <div class="analysis">${item.analysis}</div>
                    </article>
                `;
            });

            $('#resultsGrid').html(html);
            $('#resultsSection').addClass('show');

            // 显示随机洞察
            const randomInsight = CONFIG.INSIGHTS[Math.floor(Math.random() * CONFIG.INSIGHTS.length)];
            $('#insightQuote').text(`"${randomInsight}"`);

            // 滚动到结果区域
            $('html, body').animate({
                scrollTop: $('#resultsSection').offset().top - 20
            }, 500);
        }

        // ========== 事件绑定 ==========

        $(document).ready(function() {
            // 初始化：在 init 前尝试读取本地保存的代理设置
            try {
                const savedProxy = localStorage.getItem('anti_crowd_proxy_endpoint');
                if (savedProxy && savedProxy.trim()) {
                    CONFIG.PROXY_ENDPOINT = savedProxy.trim();
                    try { $('#customProxy').val(CONFIG.PROXY_ENDPOINT); } catch(e){}
                    showError('检测到已保存的代理，优先使用该代理进行请求');
                }
            } catch (e) { console.warn('读取本地代理失败', e); }

            // 初始化：加载数据
            async function init() {
                const ok = await fetchHistoryData(5, 100); // 获取500期数据：5页，每页100条
                renderHistoryList();
                renderHotspots();
                renderStats();
                if (ok) {
                    setupFullHistoryTable();
                }
            }

            init();

            // 策略卡片点击
            $('.strategy-card').on('click', function() {
                $('.strategy-card').removeClass('active');
                $(this).addClass('active');
                state.selectedStrategy = $(this).data('strategy');
            });

            // 生成按钮点击
            $('#generateBtn').on('click', async function() {
                const $btn = $(this);

                if (state.isLoading) return;
                state.isLoading = true;
                $btn.addClass('loading');

                // 模拟短暂延迟，增强体验
                await new Promise(resolve => setTimeout(resolve, 800));

                const results = generateNumbers(state.selectedStrategy);
                renderResults(results);
                
                // 生成数据分析报告
                generateAnalysisReport();

                state.isLoading = false;
                $btn.removeClass('loading');
            });

            // 刷新数据
            $('#refreshBtn').on('click', async function() {
                const $btn = $(this);
                $btn.text('刷新中...');

                const ok = await fetchHistoryData();
                if (!ok) {
                    // fetch 失败时，fetchHistoryData 会显示手动回退提示（若被拦截），此处仅确保 manual UI 可见
                    $('#manualFetchFallback').show();
                }

                renderHistoryList();
                renderStats();
                setupFullHistoryTable();

                // 当成功获取到数据后，提示用户可以将数据保存到单文件 HTML（用于离线保留）
                $('#exportBtn').prop('disabled', false).text('保存为单文件');

                $btn.text('刷新数据');
            });

            // 添加号码
            $('#addNumberBtn').on('click', function() {
                const input = $('#newNumber').val().trim();

                if (!/^\d{3}$/.test(input)) {
                    showError('请输入3位数字号码');
                    return;
                }

                // 添加到历史记录开头
                state.historyNumbers.unshift({
                    number: input,
                    rawResult: input.split('').join(' '),
                    date: new Date().toISOString().split('T')[0],
                    period: '手动添加',
                    prizeZhixuan: { stakeCount: '0', stakeAmount: '0' },
                    prizeZuxuan3: { stakeCount: '0', stakeAmount: '0' },
                    prizeZuxuan6: { stakeCount: '0', stakeAmount: '0' },
                    totalSaleAmount: '-'
                });

                $('#newNumber').val('');
                renderHistoryList();
                renderStats();
                setupFullHistoryTable();
            });

            // 回车添加号码
            $('#newNumber').on('keypress', function(e) {
                if (e.which === 13) {
                    $('#addNumberBtn').click();
                }
            });

            // 粘贴数据应用/生成单文件 HTML 按钮
            $('#applyPastedBtn').on('click', function() {
                applyPastedData(false);
            });
            $('#applyAndSaveBtn').on('click', function() {
                applyPastedData(true);
            });
            $('#clearPastedBtn').on('click', function() {
                $('#pasteJson').val('');
            });

            // ===== 文件导入 与 代理获取支持（替代 curl） =====
            function applyParsedJson(parsed, saveAndDownload = false) {
                let list = null;
                if (Array.isArray(parsed)) list = parsed;
                else if (parsed && parsed.value && Array.isArray(parsed.value.list)) list = parsed.value.list;
                else if (parsed && Array.isArray(parsed.list)) list = parsed.list;
                else if (parsed && parsed.data && Array.isArray(parsed.data.list)) list = parsed.data.list;
                else { showError('无法识别 JSON 结构，请导入接口返回的 JSON 或其中的 list 数组。'); return; }

                const normalized = list.map(normalizeApiItem).filter(i => i && i.period && i.number);
                if (normalized.length === 0) { showError('未从数据中解析到有效记录'); return; }

                state.historyNumbers = normalized.sort((a, b) => parseInt(b.period || 0) - parseInt(a.period || 0));
                renderHistoryList();
                renderStats();
                setupFullHistoryTable();
                $('#manualFetchFallback').hide();

                try {
                    localStorage.setItem('anti_crowd_history', JSON.stringify(state.historyNumbers));
                    showError('已导入数据并保存到本地（' + normalized.length + ' 条）');
                } catch (e) {
                    showError('已应用数据（' + normalized.length + ' 条）');
                }

                if (saveAndDownload) {
                    generateSelfContainedHTML();
                }
            }

            // 导入文件按钮
            $('#applyFileBtn').on('click', function() {
                const file = ($('#importFile')[0] && $('#importFile')[0].files && $('#importFile')[0].files[0]) || null;
                if (!file) { showError('请选择 JSON 文件后再导入'); return; }
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const parsed = JSON.parse(e.target.result);
                        applyParsedJson(parsed, false);
                    } catch (err) {
                        showError('文件解析失败：' + (err && err.message ? err.message : err));
                    }
                };
                reader.onerror = function() { showError('读取文件失败'); };
                reader.readAsText(file, 'utf-8');
            });

            // 文件选择时不自动提交，只做提示（用户点击导入按钮信任）
            $('#importFile').on('change', function() {
                if (this.files && this.files.length) {
                    showError('已选择文件，点击“导入并应用”开始导入');
                }
            });

            // 统一的代理尝试函数：尝试多个代理并在成功时应用解析结果
            async function attemptProxiesAndApply(proxies, target) {
                let lastErr = null;
                for (const p of proxies) {
                    try {
                        const prefix = p;
                        const url = prefix + encodeURIComponent(target);
                        const resp = await fetch(url, { method: 'GET' });
                        if (!resp.ok) throw new Error('http:' + resp.status);
                        let data = null;
                        try { data = await resp.json(); }
                        catch (e) {
                            const text = await resp.text();
                            const maybe = text.replace(/^[^(]*\((([\s\S]*)?)\);?$/, '$1');
                            data = JSON.parse(maybe);
                        }
                        applyParsedJson(data, false);
                        return true;
                    } catch (e) {
                        lastErr = e;
                        console.warn('proxy fetch failed', p, e);
                        continue;
                    }
                }
                console.warn('all proxies failed', lastErr);
                return false;
            }

            // 通过公用 CORS 代理尝试获取（用户可手动触发）
            $('#tryProxyFetchBtn').on('click', async function() {
                const $btn = $(this);
                $btn.prop('disabled', true).text('尝试中...');
                const target = (CONFIG.API_URL || '').replace(/callback=\?/, '');
                const custom = ($('#customProxy').val() || '').trim();
                const proxies = [];
                if (custom) proxies.push(custom);
                proxies.push('https://api.allorigins.win/raw?url=');
                proxies.push('https://thingproxy.freeboard.io/fetch/');

                const ok = await attemptProxiesAndApply(proxies, target);
                if (!ok) showError('通过代理获取失败，请尝试更换自定义代理或手动导入 JSON');
                $btn.prop('disabled', false).text('通过代理尝试获取');
            });

            // 复制 Cloudflare Worker 示例代码到剪贴板
            $('#copyWorkerBtn').on('click', async function() {
                const txt = $('#workerCode').text();
                try {
                    await navigator.clipboard.writeText(txt);
                    showError('已复制 Worker 示例代码到剪贴板');
                } catch (e) {
                    try {
                        const ta = document.createElement('textarea');
                        ta.value = txt;
                        document.body.appendChild(ta);
                        ta.select();
                        document.execCommand('copy');
                        ta.remove();
                        showError('已复制示例代码（备用方法）');
                    } catch (ee) {
                        showError('复制失败，请手动复制');
                    }
                }
            });

            // 显示 wrangler 部署示例
            $('#showWranglerBtn').on('click', function() {
                $('#wranglerExample').toggle();
            });

            // 保存代理为全局并测试（保存到 localStorage 并写入 CONFIG）
            $('#saveProxyBtn').on('click', async function() {
                const val = ($('#customProxy').val() || '').trim();
                if (!val) { showError('请输入代理 URL'); return; }
                try {
                    localStorage.setItem('anti_crowd_proxy_endpoint', val);
                    CONFIG.PROXY_ENDPOINT = val;
                    showError('已保存代理为全局，正在测试并尝试拉取数据...');
                    const target = (CONFIG.API_URL || '').replace(/callback=\?/, '');
                    const ok = await attemptProxiesAndApply([val], target);
                    if (ok) showError('代理测试成功并已应用数据');
                    else showError('代理测试失败，请检查 Worker 是否可访问或返回了正确的 JSON');
                } catch (e) {
                    showError('保存或测试代理时发生错误：' + (e && e.message ? e.message : e));
                }
            });

            // 测试代理但不保存
            $('#testProxyBtn').on('click', async function() {
                const $btn = $(this);
                $btn.prop('disabled', true).text('测试中...');
                const val = ($('#customProxy').val() || '').trim();
                if (!val) { showError('请输入代理 URL'); $btn.prop('disabled', false).text('测试代理'); return; }
                try {
                    const target = (CONFIG.API_URL || '').replace(/callback=\?/, '');
                    const ok = await attemptProxiesAndApply([val], target);
                    if (ok) showError('代理测试成功并已应用数据');
                    else showError('代理测试失败，请检查代理可用性');
                } catch (e) {
                    showError('测试代理时发生错误：' + (e && e.message ? e.message : e));
                } finally {
                    $btn.prop('disabled', false).text('测试代理');
                }
            });





            // 删除历史号码
            $('#historyList').on('click', '.delete-btn', function(e) {
                e.stopPropagation();
                const index = $(this).data('index');
                state.historyNumbers.splice(index, 1);
                renderHistoryList();
                renderStats();
                setupFullHistoryTable();
            });

            // 避开期数变化
            $('#avoidPeriods').on('change', function() {
                renderStats();
            });
        });
    </script>
</body>
</html>
